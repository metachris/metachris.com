<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TypeScript on Chris Hager</title><link>https://www.metachris.com/tags/typescript/</link><description>Recent content in TypeScript on Chris Hager</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 24 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.metachris.com/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>Starting a TypeScript + Node.js Project in 2021</title><link>https://www.metachris.com/2021/03/bootstrapping-a-typescript-node.js-project/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.metachris.com/2021/03/bootstrapping-a-typescript-node.js-project/</guid><description>This is a guide for starting a TypeScript + Node.js project in 2021 with modern tooling.
Project setup:
TypeScript 4 Optionally using esbuild Linting with typescript-eslint (tslint is deprecated) Testing with Jest (and ts-jest) Continuous integration (GitHub Actions / GitLab CI) Automatic API documentation with TypeDoc Building a browser-compatible module with esbuild or webpack You can clone the example repository, or follow the manual steps outlined in this post.</description></item><item><title>Custom Errors in TypeScript 2.1</title><link>https://www.metachris.com/2017/01/custom-errors-in-typescript-2.1/</link><pubDate>Fri, 06 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.metachris.com/2017/01/custom-errors-in-typescript-2.1/</guid><description>TypeScript 2.1 introduced a number of breaking changes, among them that &amp;ldquo;Extending built-ins like Error, Array, and Map may no longer work&amp;rdquo;.
For a subclass like the following:
class FooError extends Error { constructor(m: string) { super(m); } sayHello() { return &amp;#34;hello &amp;#34; + this.message; } } methods may be undefined on objects returned by constructing these subclasses, so calling sayHello will result in an error. instanceof will be broken between instances of the subclass and their instances, so (new FooError()) instanceof FooError will return false.</description></item></channel></rss>