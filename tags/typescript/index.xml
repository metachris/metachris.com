<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TypeScript on Chris Hager</title><link>https://www.metachris.com/tags/typescript/</link><description>Recent content in TypeScript on Chris Hager</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 24 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.metachris.com/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>Bootstrapping a TypeScript + Node.js Project</title><link>https://www.metachris.com/2021/03/bootstrapping-a-typescript-node.js-project/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><guid>https://www.metachris.com/2021/03/bootstrapping-a-typescript-node.js-project/</guid><description>This is a guide for bootstrapping a minimal TypeScript + Node.js project with modern tooling (March 2021).
TypeScript 4, optionally esbuild Linting with typescript-eslint (tslint is deprecated) Tests with Jest (and ts-jest) CI for testing and linting (GitHub Actions / GitLab CI) Automatic API documentation with typedoc Example repository: github.com/metachris/typescript-nodejs-boilerplate
You can either clone the example repository or follow the individual steps outlined in this post.
Notes:</description></item><item><title>Custom Errors in TypeScript 2.1</title><link>https://www.metachris.com/2017/01/custom-errors-in-typescript-2.1/</link><pubDate>Fri, 06 Jan 2017 00:00:00 +0000</pubDate><guid>https://www.metachris.com/2017/01/custom-errors-in-typescript-2.1/</guid><description>TypeScript 2.1 introduced a number of breaking changes, among them that &amp;ldquo;Extending built-ins like Error, Array, and Map may no longer work&amp;rdquo;.
For a subclass like the following:
class FooError extends Error { constructor(m: string) { super(m); } sayHello() { return &amp;#34;hello &amp;#34; + this.message; } } methods may be undefined on objects returned by constructing these subclasses, so calling sayHello will result in an error. instanceof will be broken between instances of the subclass and their instances, so (new FooError()) instanceof FooError will return false.</description></item></channel></rss>